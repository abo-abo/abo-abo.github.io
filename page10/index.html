<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      (or emacs &middot; irrelevant)
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="/public/css/octicons.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
  <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="layout-reverse theme-base-08">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- <div class="sidebar-item"> -->
  <!--   <p>unused</p> -->
  <!-- </div> -->

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive/">Archive</a>
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    

    <div id="github" class="sidebar-nav-item">
      <button type="button"
              class="btn btn-info"
              data-toggle="collapse"
              data-target="#github-projects">
        <span class="octicon octicon-mark-github"></span> My Emacs Projects
      </button>
      <div id="github-projects" class="collapse">
        <ul style="margin-bottom:0em;">
          <li>
            <a href="https://github.com/abo-abo/lispy">lispy</a>
            <p>vi-like Paredit</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/worf">worf</a>
            <p>vi-like bindings for org-mode</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/ace-window">ace-window</a>
            <p>switch windows with <code>ace-jump-mode</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/ace-link">ace-link</a>
            <p>follow links with <code>ace-jump-mode</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/function-args">function-args</a>
            <p>enhance <code>CEDET</code> for C++</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/helm-make">helm-make</a>
            <p>select a Makefile target with <code>helm</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/make-it-so">make-it-so</a>
            <p>transform files with Makefile recipes</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/org-download">org-download</a>
            <p>drag-and-drop images to <code>org-mode</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo?tab=repositories">
              <span class="octicon octicon-octoface"></span>
              and more
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>

  <div class="sidebar-item">
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License"
             style="border-width:0;opacity: 0.3;"
             src="https://licensebuttons.net/l/by-sa/4.0/88x31.png"/>
      </a>
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">(or emacs</a>
            <small>irrelevant)</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/04/09/counsel-completion/">
        Complete stuff with Counsel
      </a>
    </h1>

    <span class="post-date">09 Apr 2015</span>

    <h2 id="intro">Intro</h2>

<p>If you like my package <a href="https://github.com/abo-abo/swiper">swiper</a>,
I&#39;m sure you&#39;ll also like <a href="http://melpa.org/#/counsel">counsel</a>. It
lives in the same repository, but you can install it separately from
MELPA.</p>

<p>Counsel uses <code>ivy</code> - the same method as <code>swiper</code> to:</p>

<ul>
<li>Complete Elisp at point with <code>counsel-el</code>.</li>
<li>Complete Clojure at point with <code>counsel-clj</code>.</li>
<li>Open a git-managed file with <code>counsel-git</code>.</li>
<li>Describe an Elisp variable with <code>counsel-describe-variable</code>.</li>
<li>Describe an Elisp function with <code>counsel-describe-function</code>.</li>
<li>Look up an Elisp symbol in the info with <code>counsel-info-lookup-symbol</code>.</li>
<li>Insert a Unicode character at point with <code>counsel-unicode-char</code>.</li>
</ul>

<p>Below, I&#39;ll describe the functions that I added just today.</p>

<h3 id="counsel-describe-function"><code>counsel-describe-function</code></h3>

<p>This is just a replacement for <code>describe-function</code>:</p>

<p><img src="/download/counsel-describe-function.png" alt="counsel-describe-function.png"></p>

<p>As you can see, regular expressions work here as well.  The
space-splitting behavior is the same as in <code>swiper</code>, so don&#39;t expect
to be able to match a single space: spaces are wild.</p>

<h3 id="counsel-describe-variable"><code>counsel-describe-variable</code></h3>

<p>This is just a replacement for <code>describe-variable</code>:</p>

<p><img src="/download/counsel-describe-variable.png" alt="counsel-describe-variable.png"></p>

<p>Well, actually I&#39;ve used <code>ido-mode</code> with <code>flx</code> matching for these two
functions before. In my experience, <code>ivy</code> handles much better:</p>

<ul>
<li>you are in charge of which regex you&#39;re searching for</li>
<li>you see the candidate count</li>
<li>no crazy wrap-around candidate cycling</li>
</ul>

<p>And it works faster, too.</p>

<p>Here are my bindings:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&quot;&lt;f1&gt; f&quot;</span><span class="p">)</span> <span class="ss">&#39;counsel-describe-function</span><span class="p">)</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&quot;&lt;f1&gt; v&quot;</span><span class="p">)</span> <span class="ss">&#39;counsel-describe-variable</span><span class="p">)</span>
</code></pre></div>
<h3 id="counsel-info-lookup-symbol"><code>counsel-info-lookup-symbol</code></h3>

<p><img src="/download/counsel-info-lookup-symbol.png" alt="counsel-info-lookup-symbol.png"></p>

<p>I don&#39;t use this one too often, but it&#39;s nice to have the option:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&quot;&lt;f2&gt; i&quot;</span><span class="p">)</span> <span class="ss">&#39;counsel-info-lookup-symbol</span><span class="p">)</span>
</code></pre></div>
<h3 id="counsel-unicode-char"><code>counsel-unicode-char</code></h3>

<p><img src="/download/counsel-unicode-char.png" alt="counsel-unicode-char.png"></p>

<p>At around 40000 candidates, <code>ivy</code> starts to feel clunky (around 0.1s
display delay). Unfortunately, I don&#39;t really see a way around this,
except using tricks like <code>while-no-input</code>, which didn&#39;t work right
when I tried it earlier. It would be really cool to do the completion
in another thread, but alas.</p>

<h2 id="outro">Outro</h2>

<p>Give the new functions a try. I think <code>ivy</code> can become a viable <code>ido</code>
replacement, at least it has done so for me: the only <code>ido</code> functions
that I&#39;m still using are <code>ido-switch-buffer</code> and <code>ido-find-file</code>.</p>

<p>Also, if you&#39;re using <code>projectile</code>, you can use <code>ivy</code> completion for it:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="k">setq</span> <span class="nv">projectile-completion-system</span> <span class="ss">&#39;ivy</span><span class="p">)</span>
</code></pre></div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/04/06/lispy-multiline/">
        Rule-based multi-line in lispy
      </a>
    </h1>

    <span class="post-date">06 Apr 2015</span>

    <h2 id="where-do-one-line-expressions-come-from">Where do one-line expressions come from?</h2>

<p>When programming LISP, especially with <a href="https://github.com/abo-abo/lispy">lispy</a>, it&#39;s easy to
generate random one-line expressions. This is, of course, because the results of <code>read</code> or <code>eval</code>
don&#39;t contain any whitespace information: all original newlines are lost.</p>

<p>Just to review the multitude of ways to insert generated code into a buffer using <code>lispy</code> I&#39;ll list
the shortcuts and the test-based explanations (at around 2000 lines of tests and 54% test coverage,
<code>lispy</code> is pretty well tested).</p>

<h3 id="eval-and-insert">eval-and-insert</h3>

<p><kbd>E</kbd> calls <code>lispy-eval-and-insert</code>.</p>

<p><img src="/download/lispy-test-eval-and-insert.png" alt="lispy-test-eval-and-insert.png"></p>

<p>The image above is generated using the interactive test visualizer <code>lispy-view-test</code>, bound to
<kbd>xv</kbd>. If you want to explore how a certain command is intended to behave, just find the
corresponding test (with the same name as the command) and call <kbd>xv</kbd>.</p>

<h3 id="eval-and-replace">eval-and-replace</h3>

<p><kbd>xr</kbd> calls <code>lispy-eval-and-replace</code>.  This function evaluates the current expression and
replaces it with the result.</p>

<p><img src="/download/lispy-test-eval-and-replace.png" alt="lispy-test-eval-and-replace.png"></p>

<p>The sequence of actions in the test:</p>

<ul>
<li><kbd>e</kbd> calls <code>lispy-eval</code> to set <code>foo</code> to <code>42</code>.</li>
<li><kbd>j</kbd> calls <code>lispy-down</code> to move to the next sexp.</li>
<li><kbd>xr</kbd> calls <code>lispy-eval-and-replace</code>.</li>
</ul>

<p>Ideally, there should have been <code>&quot;xr&quot;</code> instead of <code>(lispy-eval-and-replace)</code> in the test, but
there&#39;s a small wrinkle in the <code>lispy-with</code> macro that needs to be fixed before that can happen.</p>

<h3 id="flatten">flatten</h3>

<p><kbd>xf</kbd> calls <code>lispy-flatten</code>. This function expands in-place the current function or macro
call.</p>

<p><img src="/download/lispy-test-flatten.png" alt="lispy-test-flatten.png"></p>

<p>In this test, the misleadingly named function <code>square</code> is evaluated and flattened, to see if the
<code>&amp;optional</code> and <code>&amp;rest</code> argument passing rules indeed work.</p>

<p>The flatten operation works really well for Elisp and quite well for Clojure.  The CL implementation
would need to heavily rely on SLIME features (currently absent), since the CL spec doesn&#39;t define an
equivalent of Elisp&#39;s <code>symbol-function</code>. The same applies to Scheme, I guess.</p>

<h3 id="oneline">oneline</h3>

<p><kbd>O</kbd> calls <code>lispy-oneline</code>. It&#39;s not eval-based, it just deletes the newlines.
If there are any comments present, they are pushed out.</p>

<p><img src="/download/lispy-test-oneline.png" alt="lispy-test-oneline.png"></p>

<h2 id="lispy-alt-multiline-demo-1"><code>lispy-alt-multiline</code> Demo 1</h2>

<p>In the following image, I just press <kbd>T</kbd> once, starting from an unchanged buffer:</p>

<p><img src="/download/lispy-alt-multiline-1.gif" alt="lispy-alt-multiline-1.gif"></p>

<h2 id="lispy-alt-multiline-demo-2"><code>lispy-alt-multiline</code> Demo 2</h2>

<h3 id="flatten-push">Flatten <code>push</code></h3>

<p>Start from this code (the cursor is in the CSS, if you don&#39;t see it):</p>

<div class="highlight"><pre><code class="language-elisp"
data-lang="elisp"><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">res</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
    <span class="p"><cursor>(</cursor></span><span class="nb">push</span> <span class="nv">i</span> <span class="nv">res</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">res</span><span class="p">))</span>
</code></pre></div>

<p>After <kbd>xf</kbd> it becomes:</p>

<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">res</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
    <span class="p"><cursor>(</cursor></span><span class="k">setq</span> <span class="nv">res</span>
          <span class="p">(</span><span class="nf">cons</span> <span class="nv">i</span> <span class="nv">res</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">res</span><span class="p">))</span>
</code></pre></div>

<p>Since <code>push</code> is a macro, <code>macroexpand</code> is used. And since <code>macroexpand</code> doesn&#39;t give newline
information, <code>pp-to-string</code> is used, and it gives a reasonable result.</p>

<h3 id="flatten-dotimes">Flatten <code>dotimes</code></h3>

<p>Start with the same code, but with cursor on <code>dotimes</code> this time:</p>

<div class="highlight"><pre><code class="language-elisp"
data-lang="elisp"><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">res</span><span class="p">)</span>
  <span class="p"><cursor>(</cursor></span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">push</span> <span class="nv">i</span> <span class="nv">res</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">res</span><span class="p">))</span>
</code></pre></div>

<p>After <kbd>xf</kbd> it becomes:</p>

<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">res</span><span class="p">)</span>
  <span class="p"><cursor>(</cursor></span><span class="nv">cl--block-wrapper</span>
   <span class="p">(</span><span class="k">catch</span> <span class="ss">&#39;--cl-block-nil--</span>
     <span class="p">(</span><span class="k">let</span>
         <span class="p">((</span><span class="nv">--dotimes-limit--</span> <span class="mi">10</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">i</span> <span class="mi">0</span><span class="p">))</span>
       <span class="p">(</span><span class="k">while</span>
           <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">i</span> <span class="nv">--dotimes-limit--</span><span class="p">)</span>
         <span class="p">(</span><span class="k">setq</span> <span class="nv">res</span>
               <span class="p">(</span><span class="nf">cons</span> <span class="nv">i</span> <span class="nv">res</span><span class="p">))</span>
         <span class="p">(</span><span class="k">setq</span> <span class="nv">i</span>
               <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">res</span><span class="p">))</span>
</code></pre></div>

<p>This time <code>pp-to-string</code> isn&#39;t as good: <code>let</code> and <code>while</code> statements are messed up.
Follow this up with <kbd>T</kbd> which calls <code>lispy-alt-multiline</code>:</p>

<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">res</span><span class="p">)</span>
  <span class="p"><cursor>(</cursor></span><span class="nv">cl--block-wrapper</span>
   <span class="p">(</span><span class="k">catch</span> <span class="ss">&#39;--cl-block-nil--</span>
     <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">--dotimes-limit--</span> <span class="mi">10</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">i</span> <span class="mi">0</span><span class="p">))</span>
       <span class="p">(</span><span class="k">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">i</span>
                 <span class="nv">--dotimes-limit--</span><span class="p">)</span>
         <span class="p">(</span><span class="k">setq</span> <span class="nv">res</span>
               <span class="p">(</span><span class="nf">cons</span> <span class="nv">i</span>
                     <span class="nv">res</span><span class="p">))</span>
         <span class="p">(</span><span class="k">setq</span> <span class="nv">i</span>
               <span class="p">(</span><span class="nf">1+</span>
                <span class="nv">i</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">res</span><span class="p">))</span>
</code></pre></div>

<p>Well, at least some parts look better. It could be make perfect by adding a sort of threshold when
printing each sub-expression. It&#39;s less than, say <code>15</code> chars, which <code>(setq i (1+ i))</code> is, no
newlines should be added. I&#39;ll add this a bit later.</p>

<h2 id="more-on-lispy-alt-multiline">More on <code>lispy-alt-multiline</code></h2>

<p><code>lispy-alt-multiline</code> can be used on a LISP expression to re-format it across multiple lines.  It
doesn&#39;t matter in which shape the expression currently is, since all current newlines will be removed
before the algorithm starts.</p>

<p>This has to be done with some rules, since a one-line expression can transform to multiple viable
multi-line forms. So far, these rules are implemented by customizing these variables:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="k">defvar</span> <span class="nv">lispy--multiline-take-3</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="k">defvar</span> <span class="nb">defun</span> <span class="nb">defmacro</span> <span class="nb">defcustom</span> <span class="nb">defgroup</span><span class="p">)</span>
  <span class="s">&quot;List of constructs for which the first 3 elements are on the first line.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">defvar</span> <span class="nv">lispy--multiline-take-2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">defface</span> <span class="nb">define-minor-mode</span>
  <span class="k">condition-case</span> <span class="k">while</span> <span class="nb">incf</span> <span class="nf">car</span> <span class="nf">cdr</span> <span class="nf">&gt;</span> <span class="nf">&gt;=</span> <span class="nf">&lt;</span> <span class="nf">&lt;=</span> <span class="nf">eq</span> <span class="nf">equal</span> <span class="nb">incf</span> <span class="nb">decf</span>
  <span class="nb">cl-incf</span> <span class="nb">cl-decf</span> <span class="k">catch</span> <span class="nb">require</span> <span class="nb">provide</span> <span class="k">setq</span> <span class="nf">cons</span> <span class="nb">when</span> <span class="k">if</span> <span class="nb">unless</span> <span class="k">interactive</span><span class="p">)</span>
  <span class="s">&quot;List of constructs for which the first 2 elements are on the first line.&quot;</span><span class="p">)</span>
</code></pre></div>
<p>The name suggests that there should be <code>lispy-multiline</code>, and there is, bound to <kbd>M</kbd>.  The
difference between <kbd>M</kbd> and <kbd>T</kbd> is that <kbd>M</kbd> is older and ad-hoc, while
<kbd>T</kbd> is newer and rule-based. This means that the latter can misbehave, since it&#39;s not yet
fully tested. However, it has the following built-in check to make sure that it doesn&#39;t mess up your
code:</p>

<blockquote>
<p>The <code>read</code> of the expression before transformation should be <code>equal</code> to the <code>read</code> of the
transformed expression.</p>
</blockquote>

<p>If the above check fails, no change will be performed on the source code. So your code should be
pretty safe. One more cool thing that I want to add to other operations is that it checks if the
buffer will be changed after the transformation. If there will be no change, it will just issue a
<code>&quot;No change&quot;</code> message, and no change will be performed. This is really cool if you obsess about the
buffer changed marker in the mode line like I do.</p>

<h2 id="outro">Outro</h2>

<p>The functions bound to <kbd>O</kbd>, <kbd>M</kbd>, and <kbd>T</kbd> apply to the current expression.
To be really sure which one, turn on <code>show-paren-mode</code>.  You can also call these functions not from
special, although it&#39;s not very convenient. The typical strategy in that case would be to bind all
of them on a prefix map, e.g. <kbd>C-c</kbd>.
How is it different from <a href="https://github.com/abo-abo/lispy#how-to-get-into-list-editing-mode-special">special</a> then?</p>

<blockquote>
<p>Instead of typing <kbd>[T</kbd> you would type <kbd>C-c T</kbd>.</p>
</blockquote>

<p>But the advantage of the special approach is that <kbd>[</kbd>
actually does something (moves point to the start of the current list),
instead of just being a useless part of a key combination like <kbd>C-c</kbd>.
And if you&#39;re in special already, there&#39;s no need for <kbd>[</kbd>.</p>

<p>I hope that you enjoy the new update. If it&#39;s needed, variables like <code>lispy--multiline-take-3</code> can
be made buffer-local so that <kbd>T</kbd> works appropriately for Clojure, CL and Scheme, instead of
just Elisp. If you&#39;d like to add support for your favorite dialect in this way, I&#39;d be happy to
explain some details if needed and to merge the PR. Happy hacking!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/04/02/lispy-paredit-emulation/">
        Paredit emulation in lispy
      </a>
    </h1>

    <span class="post-date">02 Apr 2015</span>

    <h2 id="intro">Intro</h2>

<p>I just finished this feature today.  Almost all Paredit functionality is available in terms of
<a href="https://github.com/abo-abo/lispy">lispy</a>&#39;s own functions.  The only functions that I didn&#39;t
implement were the ones that I didn&#39;t find any use for: <code>paredit-backslash</code> (ugh, prompts),
<code>paredit-comment-dwim</code> (covered by regular <kbd>;</kbd>), <code>paredit-forward-down</code> and
<code>paredit-backward-down</code> (both just move out of special, and throw a lot).</p>

<h2 id="setting-the-keymap-theme">Setting the keymap theme</h2>

<p>So if you ever thought that <code>lispy</code> could be a good idea, but the non-special key bindings are weird,
and you&#39;re too used to Paredit, you can now try this setting:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">lispy-set-key-theme</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">special</span> <span class="nv">paredit</span> <span class="nv">c-digits</span><span class="p">))</span>
</code></pre></div>
<p>Here&#39;s the setting that I&#39;m using, since I love <code>lispy</code>&#39;s default bindings:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">lispy-set-key-theme</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">oleh</span> <span class="nv">special</span> <span class="nv">lispy</span> <span class="nv">c-digits</span><span class="p">))</span>
</code></pre></div>
<p>The default setting actually is this one, <code>lispy-mode-map-oleh</code> is an additional map for use with
my <a href="http://oremacs.com/2015/02/14/semi-xmodmap/">Xmodmap setup</a>:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">lispy-set-key-theme</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">special</span> <span class="nv">lispy</span> <span class="nv">c-digits</span><span class="p">))</span>
</code></pre></div>
<p>Each item in the list passed to <code>lispy-set-key-theme</code> designates a keymap to turn on.
So in a non-LISP buffer you could turn on just the special map:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">lispy-set-key-theme</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">special</span><span class="p">))</span>
</code></pre></div>
<p>This would mean that zero regular bindings get overridden, but when the point is before or after a
paren, you get the <code>lispy</code> bindings. Actually, I&#39;ve just enabled <code>lispy-mode</code> for <code>markdown-mode</code>,
and it&#39;s working great. Unfortunately, I haven&#39;t yet figured out how to make a minor mode&#39;s keymap
buffer-local. Maybe someone reading has an idea.</p>

<h2 id="the-screencast">The screencast</h2>

<p>I went through all of Paredit tests and made ERT tests out of them, to make sure that the features
are actually working. I&#39;ve recorded a short (&lt;3 minutes)
<a href="https://www.youtube.com/watch?v=RDcc3RBQ9Gw">screencast</a> of implementing one of the tests.  Have a
look, maybe you&#39;ll something interesting in my setup. There are two short pauses in the video,
that&#39;s just me thinking how to write down a function. My ERT and Magit workflows are also shown.</p>

<h2 id="outro">Outro</h2>

<p>The new key-theme feature is meant to make <code>lispy</code> super-not-annoying. I think it&#39;s useful, since
using <code>lispy</code> in Paredit mode was annoying for me, so the opposite has to be true for people that
are used to Paredit. So if you notice a bug, please <a href="https://github.com/abo-abo/lispy/issues">report it</a>, bug
reports are very important for my non-annoyance agenda.</p>

<p>Finally, if you&#39;re super-devoted to Paredit and don&#39;t want to drop it, now you can easily have both
<code>lispy-mode</code> and <code>paredit-mode</code> on. Just use this setting:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">lispy-set-key-theme</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">special</span><span class="p">))</span>
</code></pre></div>
<p>Or this one if you additionally want <kbd>C-1</kbd> to show the inline doc, and <kbd>C-2</kbd> to show
the inline args:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">lispy-set-key-theme</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">special</span> <span class="nv">c-digits</span><span class="p">))</span>
</code></pre></div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/04/01/lispy.0.25.0-is-out/">
        lispy 0.25.0 is out
      </a>
    </h1>

    <span class="post-date">01 Apr 2015</span>

    <p>Seriously, check <a href="https://github.com/abo-abo/lispy/releases/tag/0.25.0">the release notes</a> if you
don&#39;t believe me.</p>

<h2 id="fixes">Fixes</h2>

<ul>
<li>Add <code>minibuffer-inactive-mode</code> to the <code>lispy-elisp-modes</code> list. It means that you can eval there if you want.</li>
<li><kbd>V</kbd> (<code>lispy-visit</code>) should turn on <code>projectile-global-mode</code> if it&#39;s not on.</li>
<li><kbd>M</kbd> (<code>lispy-multiline</code>) works better for Clojure: the regexes for vectors, maps and sets have been improved.</li>
<li><kbd>C-k</kbd> should not delete only the string when located at start of string.</li>
<li><kbd>M</kbd> will not turn vectors into lists any more.</li>
<li>the backquote bug for <kbd>i</kbd> and <kbd>M</kbd> was fixed.</li>
<li>you can flatten Elisp closures as well, at least the plain ones.</li>
</ul>

<h2 id="new-features">New Features</h2>

<h3 id="b-calls-lispy-back"><kbd>b</kbd> calls <code>lispy-back</code></h3>

<p>The movement commands, such as:</p>

<ul>
<li>the arrows <kbd>hjkl</kbd> (<code>lispy-left</code>, <code>lispy-down</code> etc.)</li>
<li><kbd>f</kbd> (<code>lispy-flow</code>)</li>
<li><kbd>q</kbd> (<code>lispy-ace-paren</code>)</li>
<li><kbd>i</kbd> (<code>lispy-tab</code>), only when called for an active region</li>
</ul>

<p>will not store each movement in the point-and-mark history. You can press <kbd>b</kbd> to go back in
history. This is especially useful for <kbd>h</kbd>, <kbd>l</kbd>, and <kbd>f</kbd>, since they are
not trivially reversible.</p>

<p><kbd>b</kbd> was previously bound to <code>lispy-store-region-and-buffer</code>, so you could do Ediff with
<kbd>b</kbd> and <kbd>B</kbd>. Now it&#39;s bound to <kbd>xB</kbd>.</p>

<h3 id="hungry-comment-delete">Hungry comment delete</h3>

<p><kbd>C-d</kbd> (<code>lispy-delete</code>) when positioned at the start of a comment, and with only whitespace
before the start of the line, will delete the whole comment.</p>

<p>If you want to un-comment, just use <kbd>C-u ;</kbd> from any point in the comment.</p>

<h3 id="added-flatten-operation-for-clojure">Added flatten operation for Clojure</h3>

<p><kbd>xf</kbd> (<code>lispy-flatten</code>) now also works for Clojure, before it was only for Elisp.</p>

<h4 id="example-1-flatten-a-macro">Example 1 (flatten a macro):</h4>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="err">|</span><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">map </span><span class="nv">sqr</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span><span class="p">))</span>
</code></pre></div>
<p>When you press <kbd>xf</kbd> you get this:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="err">|</span><span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">map </span><span class="nv">sqr</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]))</span>
</code></pre></div>
<h4 id="example-2-flatten-a-standard-function">Example 2 (flatten a standard function):</h4>

<p>Start with:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="err">|</span><span class="p">(</span><span class="nb">map </span><span class="nv">odd?</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div>
<p>After <kbd>xf</kbd>:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">f</span> <span class="nv">odd?</span> <span class="nv">coll</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]]</span>
  <span class="p">(</span><span class="nf">lazy-seq</span> <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">coll</span><span class="p">)]</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">chunked-seq?</span> <span class="nv">s</span><span class="p">)</span>
                <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">chunk-first</span> <span class="nv">s</span><span class="p">)</span>
                      <span class="nv">size</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nb">count </span><span class="nv">c</span><span class="p">))</span>
                      <span class="nv">b</span> <span class="p">(</span><span class="nf">chunk-buffer</span> <span class="nv">size</span><span class="p">)]</span>
                  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="nv">size</span><span class="p">]</span>
                    <span class="p">(</span><span class="nf">chunk-append</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">.nth</span> <span class="nv">c</span> <span class="nv">i</span><span class="p">))))</span>
                  <span class="p">(</span><span class="nf">chunk-cons</span> <span class="p">(</span><span class="nf">chunk</span> <span class="nv">b</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">(</span><span class="nf">chunk-rest</span> <span class="nv">s</span><span class="p">))))</span>
                <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">))</span>
                      <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)))))))</span>
</code></pre></div>
<p>A bit of a gibberish, but at least we can confirm that <code>map</code> is indeed lazy.</p>

<h4 id="example-3-flatten-your-own-function">Example 3 (flatten your own function):</h4>

<p>Example function:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">sqr</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</code></pre></div>
<p>This one requires the function to be properly loaded with <kbd>C-c C-l</kbd> (<code>cider-load-file</code>),
otherwise Clojure will not know the location of the function.</p>

<p>Example statement:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">+ </span><span class="err">|</span><span class="p">(</span><span class="nf">sqr</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">20</span><span class="p">)</span>
</code></pre></div>
<p>After <kbd>xf</kbd>:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">+ </span><span class="err">|</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">10</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="mi">20</span><span class="p">)</span>
</code></pre></div>
<h3 id="added-lax-eval-for-clojure">Added lax eval for Clojure</h3>

<p>This is similar to the lax eval for Elisp. If you mark an expression with a region:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">asdf [1 2 3]
</code></pre></div>
<p>and press <kbd>e</kbd>, you will actually eval this:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="nv">asdf</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
    <span class="nv">asdf</span><span class="p">)</span>
</code></pre></div>
<p>You can do this for let bindings, it&#39;s super-useful for debugging.  The rule is that if the first
element of the region is a symbol, and there&#39;s more stuff in the region besides the symbol, a lax
eval will be performed.</p>

<h3 id="e-will-auto-start-cider"><kbd>e</kbd> will auto-start CIDER</h3>

<p>If CIDER isn&#39;t live, <kbd>e</kbd> will start it and properly eval the current statement.</p>

<h3 id="2f-will-search-for-variables-first"><kbd>2F</kbd> will search for variables first</h3>

<p>Since Elisp is a LISP-2, there can be a function and a variable with the same name.  <kbd>F</kbd>
(<code>lispy-follow</code>) prefers functions, but now <kbd>2F</kbd> will prefer variables.</p>

<h3 id="2e-will-eval-and-insert-the-commented-result"><kbd>2e</kbd> will eval and insert the commented result</h3>

<p>Starting with:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="err">|</span><span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">map </span><span class="nv">sqr</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]))</span>
</code></pre></div>
<p>Pressing <kbd>2e</kbd> gives:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">map </span><span class="nv">sqr</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]))</span>
<span class="c1">;; =&gt;</span>
<span class="c1">;; (1 9 25)</span>
</code></pre></div>
<p>This works for all dialects, so you can also have:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nf">symbol-function</span> <span class="ss">&#39;exit-minibuffer</span><span class="p">)</span>
<span class="c1">;; =&gt;</span>
<span class="c1">;; (closure (t)</span>
<span class="c1">;;          nil &quot;Terminate this minibuffer argument.&quot; (interactive)</span>
<span class="c1">;;          (setq deactivate-mark nil)</span>
<span class="c1">;;          (throw (quote exit)</span>
<span class="c1">;;            nil))</span>
</code></pre></div>
<p>or</p>
<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="vg">*MODULES*</span>
<span class="c1">;; =&gt;</span>
<span class="c1">;; (&quot;SWANK-ARGLISTS&quot; &quot;SWANK-FANCY-INSPECTOR&quot; &quot;SWANK-FUZZY&quot; </span>
<span class="c1">;;                   &quot;SWANK-UTIL&quot; &quot;SWANK-PRESENTATIONS&quot; </span>
<span class="c1">;;                   &quot;SWANK-TRACE-DIALOG&quot; &quot;SB-CLTL2&quot;)</span>
</code></pre></div>
<p>To do the last eval you need to be in special.
It means that you first have to mark the symbol <code>*MODULES*</code> with a region.
A convenient function to mark the current symbol is <kbd>M-m</kbd> (<code>lispy-mark-symbol</code>).</p>

<h3 id="y-lispy-occur-now-has-an-ivy-back-end"><kbd>y</kbd> (<code>lispy-occur</code>) now has an <code>ivy</code> back end</h3>

<p><code>lispy-occur</code> launches an interactive search within the current top-level expression, usually a
defun. This is useful to see where a variable is used in a function, or to quickly navigate to a
statement.</p>

<p>You can customize <code>lispy-occur-backend</code> to either <code>ivy</code> (the default) or <code>helm</code> (if you have it,
since it&#39;s no longer a dependency of <code>lispy</code>).</p>

<h3 id="add-ivy-back-end-to-lispy-completion-method">Add ivy back end to <code>lispy-completion-method</code></h3>

<p>Now it&#39;s the default one for navigating to tags. You can select alternatively <code>helm</code> or <code>ido</code> if you
wish.</p>

<h3 id="remove-the-dependency-on-ace-jump-mode">Remove the dependency on <code>ace-jump-mode</code></h3>

<p>Instead the dependency on <code>ace-window</code> will be re-used. This allows for a lot of code
simplifications and better tests.</p>

<p>New custom variables:</p>

<ul>
<li><code>lispy-avy-style-char</code>: choose where the overlay appears for <kbd>Q</kbd> (<code>lispy-ace-char</code>)</li>
<li><code>lispy-avy-style-paren</code>: choose where the overlay appears for <kbd>q</kbd> (<code>lispy-ace-paren</code>)</li>
<li><code>lispy-avy-style-symbol</code>: choose where the overlay appears for <kbd>a</kbd> (<code>lispy-ace-symbol</code>)
and <kbd>-</kbd> (<code>lispy-ace-subword</code>) and <kbd>H</kbd> (<code>ace-symbol-replace</code>).</li>
</ul>

<p>There&#39;s also <code>lispy-avy-keys</code>, which is <code>a</code> ... <code>z</code> by default.</p>

<h3 id="add-lispy-compat">Add <code>lispy-compat</code></h3>

<p>This is a list of compatibility features with other packages, such as <code>edebug</code> and <code>god-mode</code>.
They add overhead, so you might want to turn them off if you don&#39;t use the mentioned packages.</p>

<h3 id="f-works-for-scheme"><kbd>F</kbd> works for Scheme</h3>

<p>You can navigate to a symbol definition in Scheme with <kbd>F</kbd>. This feature was already
in place for Elisp, Clojure and CL.</p>

<h2 id="outro">Outro</h2>

<p>Looks like a great batch of features, but I&#39;m the most happy about the stupid backquote bug being
fixed.</p>

<p>Up next: pre-defined key binding <a href="https://github.com/abo-abo/lispy/issues/57">themes</a>, featuring:</p>

<ul>
<li>the beloved <code>default</code>.</li>
<li>the old-school <code>paredit</code>.</li>
<li>the special-only <code>minimal</code>.</li>
<li>and maybe one more.</li>
</ul>

<p>Feel free to chime in, if you&#39;ve got a key setup that you think other people will like. Happy
hacking!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/03/30/elisp-ert-travis/">
        An update to my Elisp ERT / Travis CI setup
      </a>
    </h1>

    <span class="post-date">30 Mar 2015</span>

    <p>This post might be interesting to people who use Travis CI to test their Elisp packages.</p>

<p>I&#39;ve noticed a few days ago that my tests on Travis CI started failing randomly.  Turns out that the
widely used <a href="https://launchpad.net/%7Ecassou/+archive/ubuntu/emacs">ppa:cassou/emacs</a> has become
deprecated. It still sort of works, but sometimes <code>apt-get update</code> just times out, and I get a build
error.</p>

<p>Since it was the only one that I was using, I had to find another one. I went with <code>emacs-snapshot</code>
from <a href="https://launchpad.net/%7Eubuntu-elisp/+archive/ppa">ppa:ubuntu-elisp</a>.</p>

<p>Here&#39;s my current <a href="https://github.com/abo-abo/lispy/blob/master/.travis.yml">.travis.yml</a>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">language: emacs-lisp
env:
  matrix:
    - emacs=emacs-snapshot

before_install:
  - sudo add-apt-repository -y ppa:ubuntu-elisp
  - sudo apt-get update -qq
  - sudo apt-get install -qq $emacs
  - curl -fsSkL --max-time 10 --retry 10 --retry-delay 10 https://raw.github.com/cask/cask/master/go | python

script:
  - make cask
  - make test
</code></pre></div>
<p>I&#39;ve adopted one more change in the above code: <code>EMACS</code> is replaced by <code>emacs</code>.
The reason for this is that both <code>ansi-term</code> and <code>compile</code>
for legacy reasons set <code>EMACS</code> to <a href="https://lists.gnu.org/archive/html/emacs-devel/2015-03/msg00994.html">strange values</a>,
like <code>&quot;24.4.91.2 (term:0.96)&quot;</code>.
So if you have in your Makefile:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">EMACS ?= emacs
</code></pre></div>
<p>you&#39;re going to have a bad time. So I changed my <a href="https://github.com/abo-abo/lispy/blob/master/Makefile">Makefile</a> to:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">emacs ?= emacs
</code></pre></div>
<p>And now I can compile and test while inside Emacs with no issues.  The only issue left is that I
don&#39;t yet know which PPA I should use for a stable Emacs. Maybe someone has a suggestion.</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page11">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page9">Newer</a>
    
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
