<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      (or emacs &middot; irrelevant)
    
  </title>

  <link rel="canonical" href="https://oremacs.com/" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="/public/css/octicons.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="layout-reverse theme-base-08">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- <div class="sidebar-item"> -->
  <!--   <p>unused</p> -->
  <!-- </div> -->

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive/">Archive</a>
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    

    <div id="github" class="sidebar-nav-item">
      <button type="button"
              class="btn btn-info"
              data-toggle="collapse"
              data-target="#github-projects">
        <span class="octicon octicon-mark-github"></span> My Emacs Projects
      </button>
      <div id="github-projects" class="collapse">
        <ul style="margin-bottom:0em;">
          <li>
            <a href="https://github.com/abo-abo/lispy">lispy</a>
            <p>vi-like Paredit</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/worf">worf</a>
            <p>vi-like bindings for org-mode</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/ace-window">ace-window</a>
            <p>switch windows with <code>ace-jump-mode</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/ace-link">ace-link</a>
            <p>follow links with <code>ace-jump-mode</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/function-args">function-args</a>
            <p>enhance <code>CEDET</code> for C++</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/helm-make">helm-make</a>
            <p>select a Makefile target with <code>helm</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/make-it-so">make-it-so</a>
            <p>transform files with Makefile recipes</p>
          </li>
          <li>
            <a href="https://github.com/abo-abo/org-download">org-download</a>
            <p>drag-and-drop images to <code>org-mode</code></p>
          </li>
          <li>
            <a href="https://github.com/abo-abo?tab=repositories">
              <span class="octicon octicon-octoface"></span>
              and more
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>

  <div class="sidebar-item">
    <p>
      <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
        <img alt="Creative Commons License"
             style="border-width:0;opacity: 0.3;"
             src="https://licensebuttons.net/l/by-sa/4.0/88x31.png"/>
      </a>
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">(or emacs</a>
            <small>irrelevant)</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2017/10/04/completion-at-point/">
        Extending completion-at-point for Org-mode
      </a>
    </h1>

    <span class="post-date">04 Oct 2017</span>

    <h2 id="intro">Intro</h2>

<p>When creating documents, context aware completion is a powerful
mechanism that can help you improve the speed, correctness and
discoverability.</p>

<p>Emacs provides context aware completion via the <code>complete-symbol</code>
command, bound to <kbd>C-M-i</kbd> by default. In order for it to do
something useful, <code>completion-at-point-functions</code> has to be set up.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>Documentation:

Special hook to find the completion table for the thing at point.
Each function on this hook is called in turn without any argument and should
return either nil to mean that it is not applicable at point,
or a list of the form (START END COLLECTION) where
START and END delimit the entity to complete and should include
point, COLLECTION is the completion table to use to complete it.
</code></pre></div>
<p>For each <code>major-mode</code>, a different value of
<code>completion-at-point-functions</code> can (and probably should) apply.  One
of the modes that&#39;s set up nicely by default is <code>emacs-lisp-mode</code>:
press <kbd>C-M-i</kbd> to get completion for Elisp variable and
function names. Org-mode, on the other hand, is quite lacking in this
regard: nothing useful happens with <kbd>C-M-i</kbd>.</p>

<p>Here&#39;s my current setting for Org-mode:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">completion-at-point-functions</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nv">org-completion-symbols</span>
        <span class="nv">ora-cap-filesystem</span>
        <span class="nv">org-completion-refs</span><span class="p">))</span>
</code></pre></div>
<h2 id="org-completion-symbols">org-completion-symbols</h2>

<p>When I write about code in Org-mode, I quote items like this:</p>

<blockquote>
<p>=/home/oleh/=, =HammerFactoryFactory=, etc.</p>
</blockquote>

<p>Quoting has several advantages:</p>

<ul>
<li>It looks nice, since it&#39;s in a different face,</li>
<li><code>flyspell</code> doesn&#39;t need to check it, which makes sense since it would
fail on most variable and class names,</li>
<li>Prevents Org from confusing directory names for italics mark up.</li>
</ul>

<p>Completion has one more advantage on top of that: if I refer to a
symbol name multiple times within a document, completion helps me to
enter it quickly and correctly. Here&#39;s the corresponding completion
source:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">org-completion-symbols</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">looking-back</span> <span class="s">&quot;=[a-zA-Z]+&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">cands</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">save-match-data</span>
        <span class="p">(</span><span class="k">save-excursion</span>
          <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
          <span class="p">(</span><span class="k">while</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&quot;=\\([a-zA-Z]+\\)=&quot;</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">cl-pushnew</span>
             <span class="p">(</span><span class="nv">match-string-no-properties</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">cands</span> <span class="nb">:test</span> <span class="ss">&#39;equal</span><span class="p">))</span>
          <span class="nv">cands</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">when</span> <span class="nv">cands</span>
        <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">match-beginning</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">match-end</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">cands</span><span class="p">)))))</span>
</code></pre></div>
<ol>
<li><p>First of all, it checks if the point is e.g. after <code>=A</code>, i.e. we
are in fact entering a new quoted symbol. If that&#39;s not the case,
return <code>nil</code> and let the other completion sources have a go.</p></li>
<li><p>Next, it looks through the current buffer for each <code>=foo=</code> and
<code>=bar=</code>, accumulating them into a list.</p></li>
<li><p>Finally, it returns the bounds of what we&#39;ve got so far, plus the
found candidates. It&#39;s important that the bounds are passed to the
completion engine, so that it can delete everything inside the
bounds before inserting the whole selected symbol.</p></li>
</ol>

<h2 id="org-cap-filesystem">org-cap-filesystem</h2>

<p>This source is for completing file names:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">ora-cap-filesystem</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">path</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="k">setq</span> <span class="nv">path</span> <span class="p">(</span><span class="nv">ffap-string-at-point</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">compl</span>
             <span class="p">(</span><span class="nf">all-completions</span> <span class="nv">path</span> <span class="nf">#&#39;</span><span class="nv">read-file-name-internal</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="nv">compl</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">offset</span> <span class="p">(</span><span class="nv">ivy-completion-common-length</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">compl</span><span class="p">))))</span>
            <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">offset</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">compl</span><span class="p">)))))))</span>
</code></pre></div>
<p>I usually enter <code>~</code>, so that <code>ffap-string-at-point</code> recognizes it as a
path. Then complete each part of the path with <kbd>C-M-i</kbd>. It&#39;s
very similar to <code>counsel-find-file</code>. In fact, I could just use
<code>counsel-find-file</code> for this, with <kbd>M-o i</kbd> to insert the file
name instead of opening the selected file.</p>

<h2 id="org-completion-refs">org-completion-refs</h2>

<p><code>org-completion-refs</code> is very similar to <code>org-completion-symbols</code>: it
will collect all instances of e.g. <code>\label{foo}</code>, and offer them for
completion when you enter <code>\ref{</code>. If you want to look at the code,
it&#39;s available in <a href="https://github.com/abo-abo/oremacs/blob/github/modes/ora-org.el">my config</a>.</p>

<h2 id="outro">Outro</h2>

<p>I hope I convinced you about the usefulness of completion at
point. It&#39;s especially cool since it&#39;s a universal interface for
<code>major-mode</code>-specific completion. So any IDE-like package for any
language could provide its own completion using the familiar
interface. That could go a long way towards providing a &quot;just works&quot;
experience, particularly when dealing with a new language.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2017/08/04/ripgrep/">
        Ripgrep
      </a>
    </h1>

    <span class="post-date">04 Aug 2017</span>

    <h2 id="counsel-rg">counsel-rg</h2>

<p>Lately, due to working with a large code base, I&#39;ve grown more and
more fond of <code>counsel-rg</code>.  It&#39;s an Elisp wrapper
around <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> - a relatively
new recursive grep tool that aims to be faster than the competition
(<code>ag</code>, <code>git grep</code>, <code>pt</code>, <code>ack</code> etc).</p>

<p>Besides being really fast, <code>rg</code> also has some really
nice
<a href="https://github.com/BurntSushi/ripgrep/blob/master/doc/rg.1.md">command switches</a>.
One such switch is especially useful for Emacs:</p>

<blockquote>
<p>-M, --max-columns NUM
: Don&#39;t print lines longer than this limit in bytes. Longer lines are omitted,
 and only the number of matches in that line is printed.</p>
</blockquote>

<p>The <code>-M</code> switch is useful twofold:</p>

<ul>
<li>Emacs is slow when dealing with long lines (by long I mean thousands of chars per line)</li>
<li>Emacs is slow at accepting a huge amount of output from a process</li>
</ul>

<p>For each character you add to your input, <code>counsel-rg</code> starts a new
shell command to recalculate the matches with the new input. This
means that in order to avoid keyboard lag there&#39;s only about 0.1
seconds available for both:</p>

<ol>
<li>Running the shell command.</li>
<li>Accepting output from the shell command.</li>
</ol>

<p>So I&#39;m quite happy that <code>rg</code> speeds up both steps. Less time spent on
these steps provides for much smoother searching.</p>

<h2 id="counsel-grep-or-swiper">counsel-grep-or-swiper</h2>

<p>I also work with large log files, one file at a time. For a long time,
I&#39;ve used <code>counsel-grep-or-swiper</code> as my main search command:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&quot;C-s&quot;</span><span class="p">)</span> <span class="ss">&#39;counsel-grep-or-swiper</span><span class="p">)</span>
</code></pre></div>
<p>But for a 40Mb log file with really long lines
<code>counsel-grep-or-swiper</code> started to lag a bit. I tried <code>counsel-rg</code>,
and it was actually faster than <code>grep</code>, although it was searching the
whole directory. So I thought, why not use <code>rg</code> instead of <code>grep</code>? The
switch is actually really easy and required only a simple user
customization:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">counsel-grep-base-command</span>
 <span class="s">&quot;rg -i -M 120 --no-heading --line-number --color never &#39;%s&#39; %s&quot;</span><span class="p">)</span>
</code></pre></div>
<h2 id="outro">Outro</h2>

<p>If you haven&#39;t tried <code>ripgrep</code> so far, I suggest you give it a go. Happy hacking!</p>

<p>And if you&#39;re a C hacker and have some free time on your hands, why
not look at the long lines and the process output issues in Emacs? I&#39;d
be very grateful:)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2017/07/24/hydra-at-london-meetup/">
        hydra.el talk @ london.el
      </a>
    </h1>

    <span class="post-date">24 Jul 2017</span>

    <p>Today I gave a talk on <a href="https://github.com/abo-abo/hydra">hydra</a> at the London Emacs meet up -
<a href="https://www.meetup.com/London-Emacs-Hacking/events/241399003/">london.el</a>.
My screen capture is available on <a href="https://youtu.be/ONHEDj3kWrE">youtube</a>,
and the slides are <a href="https://oremacs.com/download/london.pdf">here</a>.</p>

<p>Thanks to <a href="https://twitter.com/dotemacs">@dotemacs</a> for organizing the
event and inviting me.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2017/04/09/ivy-0.9.0/">
        Ivy 0.9.0 is out
      </a>
    </h1>

    <span class="post-date">09 Apr 2017</span>

    <h2 id="intro">Intro</h2>

<p><a href="https://github.com/abo-abo/swiper">Ivy</a> is a completion method that&#39;s
similar to <code>Ido</code>, but with emphasis on simplicity and customizability.</p>

<h2 id="overview">Overview</h2>

<p>The current release constitutes of <code>339</code> commits and almost a full
year of progress since <code>0.8.0</code>. Many issues ranging
from <a href="https://github.com/abo-abo/swiper/issues/493">#493</a>
to <a href="https://github.com/abo-abo/swiper/issues/946">#946</a> were fixed.
The number of people who contributed code as grown
to <a href="https://github.com/abo-abo/swiper/graphs/contributors">63</a>;
thanks, everyone!</p>

<h2 id="details-on-changes">Details on changes</h2>

<p><code>Changelog.org</code> has been a part of the repository since <code>0.6.0</code>, you
can get the details of the current and past changes:</p>

<ul>
<li>in <a href="https://github.com/abo-abo/swiper/blob/master/doc/Changelog.org#090">org-mode</a></li>
<li>in <a href="http://oremacs.com/swiper/Changelog.html#0.9.0">HTML</a></li>
</ul>

<h2 id="highlights">Highlights</h2>

<p>Many improvements are incremental and don&#39;t require any extra code to
enable.  I&#39;ll go over a few selected features that require a bit of
information to make a good use of them.</p>

<h3 id="a-better-action-choice-interface">A better action choice interface</h3>

<p>For all <code>ivy</code> completions, pressing <kbd>M-o</kbd> allows to execute
one of the custom actions for the current command. Now you have an
option to use <a href="https://github.com/abo-abo/hydra">hydra</a> for selecting
an action. Use this code to turn on the feature:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;ivy-hydra</span><span class="p">)</span>
</code></pre></div>
<p>One big advantage of the new interface is that you can peak at the
action list with <kbd>M-o</kbd> without dismissing the candidate
list. Press <kbd>M-o</kbd> again to go back to candidate selection
without selecting an action.</p>

<p>Here&#39;s some code from my config that ensures that I always have some extra actions to choose from:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">ora-insert</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">insert</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">stringp</span> <span class="nv">x</span><span class="p">)</span>
       <span class="nv">x</span>
     <span class="p">(</span><span class="nf">car</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">ora-kill-new</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">kill-new</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">stringp</span> <span class="nv">x</span><span class="p">)</span>
       <span class="nv">x</span>
     <span class="p">(</span><span class="nf">car</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">ivy-set-actions</span>
 <span class="no">t</span>
 <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;i&quot;</span> <span class="nv">ora-insert</span> <span class="s">&quot;insert&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="s">&quot;w&quot;</span> <span class="nv">ora-kill-new</span> <span class="s">&quot;copy&quot;</span><span class="p">)))</span>
</code></pre></div>
<h3 id="grepping">Grepping</h3>

<p>The new <code>counsel-rg</code> joins the group of grepping commands in <code>counsel</code>
(<code>counsel-ag</code>, <code>counsel-git-grep</code>, <code>counsel-grep</code>, <code>counsel-pt</code>). It
wraps around the newly popular and very
fast <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> shell tool.</p>

<p>A nice improvement to the grepping commands is the ability to specify
extra flags when you press <kbd>C-u</kbd> (<code>universal-argument</code>)
before the
command. See <a href="https://github.com/abo-abo/swiper/pull/774">this gif</a>
for an example of excluding <code>*.el</code> from the files searched by <code>ag</code>.</p>

<h3 id="counsel-find-file">counsel-find-file</h3>

<ul>
<li><p>Press <kbd>M-o b</kbd> to change the current directory to one of the
virtual buffers&#39; directories. You continue to select a file from that
directory.</p></li>
<li><p>Press <kbd>M-o r</kbd> to find the current file as root.</p></li>
</ul>

<h3 id="counsel-git-log">counsel-git-log</h3>

<p>You can now customize
<code>counsel-git-log-cmd</code>. See
<a href="https://github.com/abo-abo/swiper/issues/652">#652</a> for using this to
make <code>counsel-git-log</code> work on Windows.</p>

<h3 id="counsel-mode">counsel-mode</h3>

<ul>
<li><code>counsel-info-lookup-symbol</code> now substitutes the built in <code>info-lookup-symbol</code>.</li>
<li>Pressing <kbd>C-r</kbd> while in the minibuffer of <code>eval-expression</code>
or <code>shell-command</code> now gives you completion of your previous
history.</li>
</ul>

<h3 id="counsel-yank-pop">counsel-yank-pop</h3>

<p>Use the new <code>counsel-yank-pop-separator</code> variable to make
<code>counsel-yank-pop</code> look
like <a href="https://github.com/abo-abo/swiper/issues/660">this</a>.</p>

<h3 id="ivy">ivy</h3>

<p>There was breaking change for alist type collections some months
ago. Right now the action functions receive an <code>item</code> from the
collection, instead of <code>(cdr item)</code> like before. If anything breaks,
the easy fix is to add an extra <code>cdr</code> to the action function.</p>

<p>Unique index for alist completion was added. The uniqueness assumption
is that the completion system is passed a list of unique strings, of
which one (or more) are selected. Unlike plain string completion,
alists may require violating the uniqueness assumption: there may be
two elements with the same <code>car</code> but different <code>cdr</code>. Example: C
function declaration and definition for tag completion. Until now,
whenever two equal strings were sent to <code>ivy-read</code>, only the first one
could be selected. Now, each alist car gets an integer index assigned
to it as a text property <code>&#39;idx</code>. So it&#39;s possible to differentiate two
alist items with the same key.</p>

<p>Action functions don&#39;t require using <code>with-ivy-window</code> anymore.  This
allows for a lot of simplification, e.g. use <code>insert</code> instead of
<code>(lambda (x) (with-ivy-window (insert x)))</code>.</p>

<h3 id="ivy-switch-buffer">ivy-switch-buffer</h3>

<p>You can now customize faces in <code>ivy-switch-buffer</code> by the mode of each buffer.
Here&#39;s a snippet from my config:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">ivy-switch-buffer-faces-alist</span>
      <span class="o">&#39;</span><span class="p">((</span><span class="nv">emacs-lisp-mode</span> <span class="o">.</span> <span class="nv">swiper-match-face-1</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">dired-mode</span> <span class="o">.</span> <span class="nv">ivy-subdir</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">org-mode</span> <span class="o">.</span> <span class="nv">org-level-4</span><span class="p">)))</span>
</code></pre></div>
<p>Looks neat, I think:</p>

<p><img src="/download/ivy-switch-buffer-faces-alist.png" alt="ivy-switch-buffer-faces-alist"></p>

<h3 id="swiper">swiper</h3>

<p>Customize <code>swiper-include-line-number-in-search</code> if you&#39;d like to
match line numbers while using <code>swiper</code>.</p>

<h2 id="new-commands">New Commands</h2>

<h3 id="counsel-bookmark">counsel-bookmark</h3>

<p>Offers completion for <code>bookmark-jump</code>. Press <kbd>M-o d</kbd> to
delete a bookmark and <kbd>M-o e</kbd> to edit it.</p>

<p>A custom option <code>counsel-bookmark-avoid-dired</code>, which is off by
default, allows to continue completion for bookmarked
directories. Turn it on with:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">counsel-bookmark-avoid-dired</span> <span class="no">t</span><span class="p">)</span>
</code></pre></div>
<p>and when you choose a bookmarked directory, the choice will be
forwarded to <code>counsel-find-file</code> instead of opening a <code>dired-mode</code>
buffer.</p>

<h3 id="counsel-colors-emacs-and-counsel-colors-web">counsel-colors-emacs and counsel-colors-web</h3>

<p>Completion for colors by name:</p>

<ul>
<li>the default action inserts the color name.</li>
<li><kbd>M-o h</kbd> inserts the color hex name.</li>
<li><kbd>M-o N</kbd> copies the color name to the kill ring.</li>
<li><kbd>M-o H</kbd> copies the color hex name to the kill ring.</li>
</ul>

<p>The colors are displayed in the minibuffer, it looks really cool:</p>

<p><img src="/download/counsel-colors-emacs.png" alt="counsel-colors-emacs"></p>

<p>You also get 108 shades of grey to choose from, for some reason.</p>

<h3 id="counsel-faces">counsel-faces</h3>

<p>Completion for faces by name:</p>

<p><img src="/download/counsel-faces.png" alt="counsel-faces"></p>

<h3 id="counsel-command-history">counsel-command-history</h3>

<p>Shows the history of the Emacs commands executed and lets you select
and eval one
again. See <a href="https://github.com/abo-abo/swiper/pull/826">#826</a> for a
nice screenshot.</p>

<h3 id="counsel-company">counsel-company</h3>

<p>Picks up <code>company</code>&#39;s candidates and inserts the result into the buffer.</p>

<h3 id="counsel-dired-jump-and-counsel-file-jump">counsel-dired-jump and counsel-file-jump</h3>

<p>Jump to a directory or a file in the current directory.</p>

<h3 id="counsel-dpkg-and-counsel-rpm">counsel-dpkg and counsel-rpm</h3>

<p>Wrap around the popular system package managers.</p>

<h3 id="counsel-package">counsel-package</h3>

<p>Install or uninstall Emacs packages with completion.</p>

<h3 id="counsel-mark-ring">counsel-mark-ring</h3>

<p>Navigate the current buffer&#39;s mark ring.</p>

<h3 id="counsel-semantic">counsel-semantic</h3>

<p>Navigate the current buffer&#39;s tags.</p>

<h3 id="counsel-outline">counsel-outline</h3>

<p>Navigate the current buffer&#39;s outlines.</p>

<h3 id="counsel-recentf">counsel-recentf</h3>

<p>Completion for <code>recentf</code>.</p>

<h3 id="counsel-find-library">counsel-find-library</h3>

<p>Completion for <code>find-library</code>.</p>

<h3 id="counsel-hydra-heads">counsel-hydra-heads</h3>

<p>Completion for the last hydra&#39;s heads.</p>

<h3 id="counsel-org-agenda-headlines">counsel-org-agenda-headlines</h3>

<p>Completion for headlines of files in your <code>org-agenda-files</code>.</p>

<h2 id="outro">Outro</h2>

<p>Again, thanks to all the contributors. Happy hacking!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2017/03/28/emacs-cpp-ide/">
        Using Emacs as a C++ IDE
      </a>
    </h1>

    <span class="post-date">28 Mar 2017</span>

    <p>Recently, I&#39;ve had to code some C++ at work. And I saw it as a good
opportunity to step up my Emacs&#39; IDE game. I&#39;ve eschewed clang-based
tools until now, but GCC isn&#39;t adding AST support any time soon, and
CEDET is too slow and too clumsy with macros for the particular
project that I
had. Here&#39;s
<a href="https://bitbucket.org/eigen/eigen/src/525f03452c37a400bcc4df194950fa97aa61936a/Eigen/src/Core/Matrix.h?at=default&fileviewer=file-view-default#Matrix.h-426">the line</a> in
<a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a> that
broke the camel&#39;s back. Basically it&#39;s 30 lines of macros that expand
to 30 lines of typedefs. Maybe it&#39;s a valid implementation choice, I&#39;d
rather avoid the macros altogether, but in any case I couldn&#39;t get
CEDET to parse that.</p>

<h2 id="use-rtags-for-navigation">Use Rtags for navigation</h2>

<p>The first thing I tried
was <a href="https://github.com/Andersbakken/rtags">rtags</a>.  My project was
CMake-based, so I just put this line in my subdirectory <code>Makefile</code>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>cmake:
    cd ../build &amp;&amp; cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ..
</code></pre></div>
<p>The <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=1</code> causes a
<code>compile_commands.json</code> file to be emitted during the actual
compilation. This file describes the compile flags for every source
file. These flags are essential in helping the parser understand
what&#39;s going on.</p>

<p>Then, in the <code>build</code> directory I start:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>rdm &amp; jc -J .
</code></pre></div>
<p>Finally, <code>rtags-find-symbol-at-point</code> should work now. I still like to
use CEDET as backup, it&#39;s pretty good at tracking variables
defined in the current function:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">ciao-goto-symbol</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">deactivate-mark</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">ring-insert</span> <span class="nv">find-tag-marker-ring</span> <span class="p">(</span><span class="nf">point-marker</span><span class="p">))</span>
  <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;rtags</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">rtags-find-symbol-at-point</span><span class="p">))</span>
      <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;semantic/ia</span><span class="p">)</span>
           <span class="p">(</span><span class="k">condition-case</span> <span class="no">nil</span>
               <span class="p">(</span><span class="nv">semantic-ia-fast-jump</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
             <span class="p">(</span><span class="ne">error</span> <span class="no">nil</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">define-key</span> <span class="nv">c++-mode-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&quot;M-.&quot;</span><span class="p">)</span> <span class="ss">&#39;ciao-goto-symbol</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-key</span> <span class="nv">c++-mode-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&quot;M-,&quot;</span><span class="p">)</span> <span class="ss">&#39;pop-tag-mark</span><span class="p">)</span>
</code></pre></div>
<p>For my other C++ projects which aren&#39;t CMake-based, I use the
excellent <a href="https://github.com/rizsotto/Bear">bear</a> tool to emit the
<code>compile_commands.json</code> file. It&#39;s as easy as:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span></span>make clean
bear make
</code></pre></div>
<h2 id="use-irony-for-completion">Use Irony for completion</h2>

<p>It didn&#39;t take long to figure out that <code>rtags</code> isn&#39;t great at
completion. I almost accepted that&#39;s just the way it is.  But this
morning I decided to make some changes and
try <a href="https://github.com/Sarcasm/irony-mode">irony-mode</a>.  And it
worked beautifully for completion! What&#39;s ironic, is that <code>irony-mode</code>
doesn&#39;t have <code>goto-symbol</code>, so the time spent to figure out <code>rtags</code>
was worth it.</p>

<p>Here&#39;s my Irony setup; I only changed the <kbd>C-M-i</kbd> binding to
the newly written <code>counsel-irony</code>, now available in the <code>counsel</code>
package on MELPA:</p>
<div class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span></span><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;c++-mode-hook</span> <span class="ss">&#39;irony-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;c-mode-hook</span> <span class="ss">&#39;irony-mode</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">my-irony-mode-hook</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">define-key</span> <span class="nv">irony-mode-map</span>
      <span class="p">[</span><span class="nv">remap</span> <span class="nv">completion-at-point</span><span class="p">]</span> <span class="ss">&#39;counsel-irony</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">define-key</span> <span class="nv">irony-mode-map</span>
      <span class="p">[</span><span class="nv">remap</span> <span class="nv">complete-symbol</span><span class="p">]</span> <span class="ss">&#39;counsel-irony</span><span class="p">))</span>
<span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;irony-mode-hook</span> <span class="ss">&#39;my-irony-mode-hook</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;irony-mode-hook</span> <span class="ss">&#39;irony-cdb-autosetup-compile-options</span><span class="p">)</span>
</code></pre></div>
<p>And here are some screenshots of <code>counsel-irony</code>:</p>

<p><img src="/download/counsel-irony-1.png" alt="screenshot-1"></p>

<p>First of all, the completion is displayed inline, similarly to modern IDEs.
You can use all of Ivy&#39;s regex tricks to complete your candidate:</p>

<p><img src="/download/counsel-irony-2.png" alt="screenshot-2"></p>

<p>Note how the power of regex matching allows me to narrow the initial
1622 candidates to only 22 functions that have <code>src1</code> and <code>src2</code> as
arguments. One of the candidates is cut off for being longer than the
window width. You can still match against the invisible text, but you
won&#39;t see it. It&#39;s possible to use <kbd>C-c C-o</kbd> (<code>ivy-occur</code>) to
store the current candidates into a buffer:</p>

<p><img src="/download/counsel-irony-3.png" alt="screenshot-3"></p>

<p>Clicking the mouse on any of the lines in the new buffer will insert
the appropriate symbol into the C++ buffer.</p>

<h2 id="outro">Outro</h2>

<p>I&#39;d like to thank the authors of <code>rtags</code> and <code>irony-mode</code> for these
nice packages. Hopefully, <code>counsel-irony</code> is a nice addition. Happy
hacking!</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
